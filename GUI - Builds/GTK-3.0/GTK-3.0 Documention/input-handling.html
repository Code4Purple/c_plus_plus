<!--
SPDX-FileCopyrightText: GTK Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Gtk &ndash; 3.0: The GTK Input and Event Handling Model</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  
  <meta property="og:image:width" content="256"/>
  <meta property="og:image:height" content="256"/>
  <meta property="og:image:secure_url" content="gtk-logo.svg"/>
  <meta property="og:image:alt" content="Gtk-3.0"/>
  

  
  <meta property="og:title" content="Gtk: The GTK Input and Event Handling Model"/>
  <meta property="og:description" content="Reference for Gtk-3.0: The GTK Input and Event Handling Model"/>
  <meta name="twitter:title" content="Gtk: The GTK Input and Event Handling Model"/>
  <meta name="twitter:description" content="Reference for Gtk-3.0: The GTK Input and Event Handling Model"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Gtk" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      <div class="section">
        <a href="index.html"><img src="gtk-logo.svg" class="logo"/></a>
      </div>
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Gtk</a></h3>
        <p>API Version: 3.0</p>
        
        <p>Library Version: 3.24</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2024.2</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    The GTK Input and Event Handling Model
    <a href="input-handling.html#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h2 id="overview-of-gtk-input-and-event-handling">Overview of GTK input and event handling<a class="md-anchor" href="input-handling.html#overview-of-gtk-input-and-event-handling" title="Permanent link"></a></h2>
<p>This chapter describes in detail how <span class="caps">GTK</span> handles input. If you are
interested in what happens to translate a key press or mouse motion of the
users into a change of a <span class="caps">GTK</span> widget, you should read this chapter. This
knowledge will also be useful if you decide to implement your own&nbsp;widgets.</p>
<h3 id="devices-and-events">Devices and events<a class="md-anchor" href="input-handling.html#devices-and-events" title="Permanent link"></a></h3>
<p>The most basic input devices that every computer user has interacted with
are keyboards and mice; beyond these, <span class="caps">GTK</span> supports touchpads, touchscreens
and more exotic input devices such as graphics tablets. Inside <span class="caps">GTK</span>, every
such input device is represented by a <a href="javascript:void(0)" data-namespace="Gdk" data-link="class.Device.html" class="external"><code>GdkDevice</code></a>&nbsp;object.</p>
<p>To simplify dealing with the variability between these input devices, <span class="caps">GTK</span>
has a concept of logical and physical devices. The concrete physical devices
that have many different characteristics (mice may have 2 or 3 or 8 buttons,
keyboards have different layouts and may or may not have a separate number
block, etc) are represented as &#8220;slave&#8221; devices. Each physical device is
associated with a virtual logical device. Logical devices always come in
pointer/keyboard pairs - you can think of such a pair as a&nbsp;&#8216;seat&#8217;.</p>
<p><span class="caps">GTK</span> widgets generally deal with the logical devices, and thus can be used
with any pointing device or&nbsp;keyboard.</p>
<p>When a user interacts with an input device (e.g. moves a mouse or presses a
key on the keyboard), <span class="caps">GTK</span> receives events from the windowing system. These
are typically directed at a specific window - for pointer events, the window
under the pointer (grabs complicate this), for keyboard events, the window
with the keyboard&nbsp;focus.</p>
<p><span class="caps">GDK</span> translates these raw windowing system events into <code>GdkEvent</code>s. Typical
input events&nbsp;are:</p>
<ul>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventButton.html" class="external"><code>GdkEventButton</code></a></li>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventMotion.html" class="external"><code>GdkEventMotion</code></a></li>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventCrossing.html" class="external"><code>GdkEventCrossing</code></a></li>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventKey.html" class="external"><code>GdkEventKey</code></a></li>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventFocus.html" class="external"><code>GdkEventFocus</code></a></li>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventTouch.html" class="external"><code>GdkEventTouch</code></a></li>
</ul>
<p>Additionally, <span class="caps">GDK</span>/<span class="caps">GTK</span> synthesizes other signals to let know whether grabs
(system-wide or in-app) are taking input&nbsp;away:</p>
<ul>
<li><a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventGrabBroken.html" class="external"><code>GdkEventGrabBroken</code></a></li>
<li><a href="signal.Widget.grab-notify.html"><code>GtkWidget::grab-notify</code></a></li>
</ul>
<p>When <span class="caps">GTK</span> is initialized, it sets up an event handler function with
<a href="javascript:void(0)" data-namespace="Gdk" data-link="type_func.Event.handler_set.html" class="external"><code>gdk_event_handler_set()</code></a>, which receives all of these input events (as
well as others, for instance window management related&nbsp;events).</p>
<h3 id="event-propagation">Event propagation<a class="md-anchor" href="input-handling.html#event-propagation" title="Permanent link"></a></h3>
<p>For widgets which have a <a href="javascript:void(0)" data-namespace="Gdk" data-link="class.Window.html" class="external"><code>GdkWindow</code></a> set, events are received from
the windowing system and passed to <a href="func.main_do_event.html"><code>gtk_main_do_event()</code></a>. See its
documentation for details of what it does: compression of enter/leave
events, identification of the widget receiving the event, pushing the event
onto a stack for <a href="func.get_current_event.html"><code>gtk_get_current_event()</code></a>, and propagating the event
to the&nbsp;widget.</p>
<p>When a <span class="caps">GDK</span> backend produces an input event, it is tied to a <code>GdkDevice</code> and
a <code>GdkWindow</code>, which in turn represents a windowing system surface in the
backend. If a widget has grabbed the current input device, or all input
devices, the event is propagated to that <code>GtkWidget</code>. Otherwise, it is
propagated to the the GtkWidget which called
<a href="method.Widget.register_window.html"><code>gtk_widget_register_window()</code></a> on the <code>GdkWindow</code> receiving the&nbsp;event.</p>
<p>Grabs are implemented for each input device, and globally. A grab for a
specific input device (<a href="func.device_grab_add.html"><code>gtk_device_grab_add()</code></a>), is sent events in
preference to a global grab (<a href="method.Widget.grab_add.html"><code>gtk_grab_add()</code></a>). Input grabs
only have effect within the <a href="class.WindowGroup.html"><code>GtkWindowGroup</code></a> containing the
<code>GtkWidget</code> which registered the event’s <code>GdkWindow</code>. If this <code>GtkWidget</code> is
a child of the grab widget, the event is propagated to the child — this is
the basis for propagating events within modal&nbsp;dialogs.</p>
<p>An event is propagated to a widget using <a href="func.propagate_event.html"><code>gtk_propagate_event()</code></a>.
Propagation differs between event types: key events (<code>GDK_KEY_PRESS</code>,
<code>GDK_KEY_RELEASE</code>) are delivered to the top-level <code>GtkWindow</code>; other events
are propagated down and up the widget hierarchy in three phases (see
<a href="enum.PropagationPhase.html"><code>GtkPropagationPhase</code></a>).</p>
<p>For key events, the top-level window’s default
<a href="signal.Widget.key-press-event.html"><code>GtkWidget::key-press-event</code></a> and
<a href="signal.Widget.key-release-event.html"><code>GtkWidget::key-release-event</code></a> signal handlers handle mnemonics and
accelerators first. Other key presses are then passed to
<a href="method.Window.propagate_key_event.html"><code>gtk_window_propagate_key_event()</code></a> which propagates the event upwards
from the window’s current focus widget (<a href="method.Window.get_focus.html"><code>gtk_window_get_focus()</code></a>) to
the&nbsp;top-level.</p>
<p>For other events, in the first phase (the “capture” phase) the event is
delivered to each widget from the top-most (for example, the top-level
<code>GtkWindow</code> or grab widget) down to the target <code>GtkWidget</code>. Gestures that are
attached with <code>GTK_PHASE_CAPTURE</code> get a chance to react to the&nbsp;event.</p>
<p>After the “capture” phase, the widget that was intended to be the
destination of the event will run gestures attached to it with
<code>GTK_PHASE_TARGET</code>. This is known as the “target” phase, and only happens on
that&nbsp;widget.</p>
<p>Next, the “event” signal is emitted, then the appropriate signal for the
event in question, for example <a href="signal.Widget.motion-notify-event.html"><code>GtkWidget::motion-notify-event</code></a>.
Handling these signals was the primary way to handle input in <span class="caps">GTK</span> widgets
before gestures were introduced. If the widget is realized, the
<a href="signal.Widget.event-after.html"><code>GtkWidget::event-after</code></a> signal is emitted. The signals are emitted
from the target widget up to the top-level, as part of the “bubble”&nbsp;phase.</p>
<p>The default handlers for the event signals send the event to gestures that
are attached with <code>GTK_PHASE_BUBBLE</code>. Therefore, gestures in the “bubble”
phase are only used if the widget does not have its own event handlers, or
takes care to chain up to the default <code>GtkWidget</code> handlers.</p>
<p>Events are not delivered to a widget which is insensitive or&nbsp;unmapped.</p>
<p>Any time during the propagation phase, a widget may indicate that a received
event was consumed and propagation should therefore be stopped. In
traditional event handlers, this is hinted by returning <code>GDK_EVENT_STOP</code>. If
gestures are used, this may happen when the widget tells the gesture to
claim the event touch sequence (or the pointer events) for its own. See the
&#8220;gesture states&#8221; section below to know more of the&nbsp;latter.</p>
<h3 id="event-masks">Event masks<a class="md-anchor" href="input-handling.html#event-masks" title="Permanent link"></a></h3>
<p>Each widget instance has a basic event mask and another per input device,
which determine the types of input event it receives. Each event mask set on
a widget is added to the corresponding (basic or per-device) event mask for
the widget’s <code>GdkWindow</code>, and all child <code>GdkWindows</code>.</p>
<p>If a widget is windowless (<a href="method.Widget.get_has_window.html"><code>gtk_widget_get_has_window()</code></a> returns
<code>FALSE</code>) and an application wants to receive custom events on it, it must be
placed inside a <a href="class.EventBox.html"><code>GtkEventBox</code></a> to receive the events, and an
appropriate event mask must be set on the box. When implementing a widget,
use a <code>GDK_INPUT_ONLY</code> <code>GdkWindow</code> to receive the events&nbsp;instead.</p>
<p>Filtering events against event masks happens inside <code>GdkWindow</code>, which exposes
event masks to the windowing system to reduce the number of events <span class="caps">GDK</span>
receives from it. On receiving an event, it is filtered against the
<code>GdkWindow</code>’s mask for the input device, if set. Otherwise, it is filtered
against the <code>GdkWindow</code>’s basic event&nbsp;mask.</p>
<p>This means that widgets must add to the event mask for each event type they
expect to receive, using <a href="method.Widget.set_events.html"><code>gtk_widget_set_events()</code></a> or
<a href="method.Widget.add_events.html"><code>gtk_widget_add_events()</code></a> to preserve the existing mask. Widgets
which are aware of floating devices should use
<a href="method.Widget.set_device_events.html"><code>gtk_widget_set_device_events()</code></a> or
<a href="method.Widget.add_device_events.html"><code>gtk_widget_add_device_events()</code></a>, and must explicitly enable the
device using <a href="method.Widget.set_device_enabled.html"><code>gtk_widget_set_device_enabled()</code></a>. See the
<a href="javascript:void(0)" data-namespace="Gdk" data-link="class.DeviceManager.html" class="external"><code>GdkDeviceManager</code></a> documentation for more&nbsp;information.</p>
<p>All standard widgets set the event mask for all events they expect to
receive, and it is not necessary to modify this. Masks should be set when
implementing a new&nbsp;widget.</p>
<h3 id="touch-events">Touch events<a class="md-anchor" href="input-handling.html#touch-events" title="Permanent link"></a></h3>
<p>Touch events are emitted as events of type <code>GDK_TOUCH_BEGIN</code>,
<code>GDK_TOUCH_UPDATE</code> or <code>GDK_TOUCH_END</code>, those events contain an “event
sequence” that univocally identifies the physical touch until it is lifted
from the&nbsp;device.</p>
<p>On some windowing platforms, multitouch devices perform pointer emulation,
this works by granting a “pointer emulating” hint to one of the currently
interacting touch sequences, which will be reported on every <a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventTouch.html" class="external"><code>GdkEventTouch</code></a>
event from that sequence. By default, if a widget didn&#8217;t request touch
events by setting <code>GDK_TOUCH_MASK</code> on its event mask and didn&#8217;t override
<a href="signal.Widget.touch-event.html"><code>GtkWidget::touch-event</code></a>, <span class="caps">GTK</span> will transform these “pointer emulating” events into
semantically similar <code>GdkEventButton</code> and <code>GdkEventMotion</code> events. Depending on
<code>GDK_TOUCH_MASK</code> being in the event mask or not, non-pointer-emulating
sequences could still trigger gestures or just get filtered out, regardless
of the widget not handling those&nbsp;directly.</p>
<p>If the widget sets <code>GDK_TOUCH_MASK</code> on its event mask and doesn&#8217;t chain up
on <code>GtkWidget::touch-event</code>, only touch events will be received, and no
pointer emulation will be&nbsp;performed.</p>
<h3 id="grabs">Grabs<a class="md-anchor" href="input-handling.html#grabs" title="Permanent link"></a></h3>
<p>Grabs are a method to claim all input events from a device, they happen
either implicitly on pointer and touch devices, or explicitly. Implicit
grabs happen on user interaction, when a <code>GDK_BUTTON_PRESS</code> event type
happens, all events from then on, until after the corresponding
<code>GDK_BUTTON_RELEASE</code> event type, will be reported to the widget that got the
first event. Likewise, on touch events, every <code>GdkEventSequence</code> will deliver
only events to the widget that received its <code>GDK_TOUCH_BEGIN</code> event.</p>
<p>Explicit grabs happen programatically (both activation and deactivation),
and can be either system-wide (<span class="caps">GDK</span> grabs) or application-wide (<span class="caps">GTK</span> grabs).
On the windowing platforms that support it, <span class="caps">GDK</span> grabs will prevent any
interaction with any other application/window/widget than the grabbing one,
whereas <span class="caps">GTK</span> grabs will be effective only within the application (across all
its windows), still allowing for interaction with other&nbsp;applications.</p>
<p>But one important aspect of grabs is that they may potentially happen at any
point somewhere else, even while the pointer/touch device is already
grabbed. This makes it necessary for widgets to handle the cancellation of
any ongoing interaction. Depending on whether a <span class="caps">GTK</span> or <span class="caps">GDK</span> grab is causing
this, the widget will respectively receive a
<a href="signal.Widget.grab-notify.html"><code>GtkWidget::grab-notify</code></a> signal, or a <a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.EventGrabBroken.html" class="external"><code>GdkEventGrabBroken</code></a>&nbsp;event.</p>
<p>On gestures, these signals are handled automatically, causing the gesture to
cancel all tracked pointer/touch events, and signal the end of&nbsp;recognition.</p>
<h3 id="keyboard-input">Keyboard input<a class="md-anchor" href="input-handling.html#keyboard-input" title="Permanent link"></a></h3>
<h3 id="event-controllers-and-gestures">Event controllers and gestures<a class="md-anchor" href="input-handling.html#event-controllers-and-gestures" title="Permanent link"></a></h3>
<p>Event controllers are standalone objects that can perform specific actions
upon received <code>GdkEvent</code>s. These are tied to a <code>GtkWidget</code>, and can be told
of the event propagation phase at which they will manage the&nbsp;events.</p>
<p>Gestures are a set of specific controllers that are prepared to handle
pointer and/or touch events, each gestures implementation attempts to
recognize specific actions out the received events, notifying of the
state/progress accordingly to let the widget react to those. On multi-touch
gestures, every interacting touch sequence will be tracked&nbsp;independently.</p>
<p>Being gestures “simple” units, it is not uncommon to tie several together to
perform higher level actions, grouped gestures handle the same event
sequences simultaneously, and those sequences share a same state across all
grouped gestures. Some examples of grouping may&nbsp;be:</p>
<ul>
<li>A “drag” and a “swipe” gestures may want grouping. The former will report
  events as the dragging happens, the latter will tell the swipe X/Y
  velocities only after gesture has&nbsp;finished.</li>
<li>Grouping a “drag” gesture with a “pan” gesture will only effectively allow
  dragging in the panning orientation, as both gestures share&nbsp;state.</li>
</ul>
<p>If “press” and “long press” are wanted simultaneously, those would need&nbsp;grouping.</p>
<h3 id="gesture-states">Gesture states<a class="md-anchor" href="input-handling.html#gesture-states" title="Permanent link"></a></h3>
<p>Gestures have a notion of “state” for each individual touch sequence. When
events from a touch sequence are first received, the touch sequence will
have “none” state, this means the touch sequence is being handled by the
gesture to possibly trigger actions, but the event propagation will not be&nbsp;stopped.</p>
<p>When the gesture enters recognition, or at a later point in time, the widget
may choose to claim the touch sequences (individually or as a group), hence
stopping event propagation after the event is run through every gesture in
that widget and propagation phase. Anytime this happens, the touch sequences
are cancelled downwards the propagation chain, to let these know that no
further events will be&nbsp;sent.</p>
<p>Alternatively, or at a later point in time, the widget may choose to deny
the touch sequences, thus letting those go through again in event
propagation. When this happens in the capture phase, and if there are no
other claiming gestures in the widget, a
<code>GDK_TOUCH_BEGIN</code>/<code>GDK_BUTTON_PRESS</code> event will be emulated and propagated
downwards, in order to preserve&nbsp;consistency.</p>
<p>Grouped gestures always share the same state for a given touch sequence, so
setting the state on one does transfer the state to the others. They also
are mutually exclusive, within a widget there may be only one gesture group
claiming a given sequence. If another gesture group claims later that same
sequence, the first group will deny the&nbsp;sequence.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="input-handling.html#devices-and-events"><span class="link-text">Devices and events</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#event-propagation"><span class="link-text">Event propagation</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#event-masks"><span class="link-text">Event masks</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#touch-events"><span class="link-text">Touch events</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#grabs"><span class="link-text">Grabs</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#keyboard-input"><span class="link-text">Keyboard input</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#event-controllers-and-gestures"><span class="link-text">Event controllers and gestures</span></a></li>
        
        <li class="toc-list-item"><a href="input-handling.html#gesture-states"><span class="link-text">Gesture states</span></a></li>
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>