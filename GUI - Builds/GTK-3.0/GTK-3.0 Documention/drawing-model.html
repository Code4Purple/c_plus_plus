<!--
SPDX-FileCopyrightText: GTK Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Gtk &ndash; 3.0: The GTK Drawing Model</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8" />

  
  <meta property="og:type" content="website"/>

  
  <meta property="og:image:width" content="256"/>
  <meta property="og:image:height" content="256"/>
  <meta property="og:image:secure_url" content="gtk-logo.svg"/>
  <meta property="og:image:alt" content="Gtk-3.0"/>
  

  
  <meta property="og:title" content="Gtk: The GTK Drawing Model"/>
  <meta property="og:description" content="Reference for Gtk-3.0: The GTK Drawing Model"/>
  <meta name="twitter:title" content="Gtk: The GTK Drawing Model"/>
  <meta name="twitter:description" content="Reference for Gtk-3.0: The GTK Drawing Model"/>


  
  <meta name="twitter:card" content="summary"/>

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="Gtk" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css" />

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    <nav class="sidebar devhelp-hidden">
      
      <div class="section">
        <a href="index.html"><img src="gtk-logo.svg" class="logo"/></a>
      </div>
      
      
      <div class="search section">
        <form id="search-form" autocomplete="off">
          <input id="search-input" type="text" name="do-not-autocomplete" placeholder="Click, or press 's' to search" autocomplete="off"/>
        </form>
      </div>
      
      <div class="section namespace">
        <h3><a href="index.html">Gtk</a></h3>
        <p>API Version: 3.0</p>
        
        <p>Library Version: 3.24</p>
        
      </div>
      
      
      <div class="section generator">
        <p>Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2024.2</p>
      </div>
    </nav>

    <button id="btn-to-top" class="hidden"><span class="up-arrow"></span></button>

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    The GTK Drawing Model
    <a href="drawing-model.html#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h2 id="overview-of-the-drawing-model">Overview of the drawing model<a class="md-anchor" href="drawing-model.html#overview-of-the-drawing-model" title="Permanent link"></a></h2>
<p>This chapter describes the <span class="caps">GTK</span> drawing model in detail. If you are
interested in the procedure which <span class="caps">GTK</span> follows to draw its widgets and
windows, you should read this chapter; this will be useful to know if you
decide to implement your own widgets. This chapter will also clarify the
reasons behind the ways certain things are done in <span class="caps">GTK</span>; for example, why you
cannot change the background color of all widgets with the same&nbsp;method.</p>
<h3 id="windows-and-events">Windows and events<a class="md-anchor" href="drawing-model.html#windows-and-events" title="Permanent link"></a></h3>
<p>Programs that run in a windowing system generally create rectangular regions
in the screen called windows. Traditional windowing systems do not
automatically save the graphical content of windows, and instead ask client
programs to repaint those windows whenever it is needed. For example, if a
window that is stacked below other windows gets raised to the top, then a
client program has to repaint the area that was previously obscured. When
the windowing system asks a client program to redraw part of a window, it
sends an exposure event to the program for that&nbsp;window.</p>
<p>Here, &#8220;windows&#8221; means &#8220;rectangular regions with automatic clipping&#8221;, instead
of &#8220;toplevel application windows&#8221;. Most windowing systems support nested
windows, where the contents of child windows get clipped by the boundaries
of their parents. Although <span class="caps">GTK</span> and <span class="caps">GDK</span> in particular may run on a windowing
system with no such notion of nested windows, <span class="caps">GDK</span> presents the illusion of
being under such a system. A toplevel window may contain many subwindows and
sub-subwindows, for example, one for the menu bar, one for the document
area, one for each scrollbar, and one for the status bar. In addition,
controls that receive user input, such as clickable buttons, are likely to
have their own subwindows as&nbsp;well.</p>
<p>In practice, most windows in modern <span class="caps">GTK</span> application are client-side
constructs. Only few windows (in particular toplevel windows) are native,
which means that they represent a window from the underlying windowing
system on which <span class="caps">GTK</span> is running. For example, on X11 it corresponds to a
<code>Window</code>; on Windows, it corresponds to a <code>HANDLE</code>.</p>
<p>Generally, the drawing cycle begins when <span class="caps">GTK</span> receives an exposure event from
the underlying windowing system: if the user drags a window over another
one, the windowing system will tell the underlying window that it needs to
repaint itself. The drawing cycle can also be initiated when a widget itself
decides that it needs to update its display. For example, when the user
types a character in a <code>GtkEntry</code> widget, the entry asks <span class="caps">GTK</span> to queue a
redraw operation for&nbsp;itself.</p>
<p>The windowing system generates events for native windows. The <span class="caps">GDK</span> interface
to the windowing system translates such native events into
<a href="javascript:void(0)" data-namespace="Gdk" data-link="struct.Event.html" class="external"><code>GdkEvent</code></a> structures and sends them on to the <span class="caps">GTK</span> layer. In turn,
the <span class="caps">GTK</span> layer finds the widget that corresponds to a particular
<a href="javascript:void(0)" data-namespace="Gdk" data-link="class.Window.html" class="external"><code>GdkWindow</code></a> and emits the corresponding event signals on that&nbsp;widget.</p>
<p>The following sections describe how <span class="caps">GTK</span> decides which widgets need to be
repainted in response to such events, and how widgets work internally in
terms of the resources they use from the windowing&nbsp;system.</p>
<h3 id="the-frame-clock">The frame clock<a class="md-anchor" href="drawing-model.html#the-frame-clock" title="Permanent link"></a></h3>
<p>All <span class="caps">GTK</span> applications are mainloop-driven, which means that most of the time
the app is idle inside a loop that just waits for something to happen and
then calls out to the right place when it does. On top of this <span class="caps">GTK</span> has a
frame clock that gives a “pulse” to the application. This clock beats at a
steady rate, which is tied to the framerate of the output (this is synced to
the monitor via the window manager/compositor). The clock has several&nbsp;phases:</p>
<ul>
<li>Events</li>
<li>Update</li>
<li>Layout</li>
<li>Paint</li>
</ul>
<p>The phases happens in this order and we will always run each phase through
before going back to the&nbsp;start.</p>
<p>The <em>Events</em> phase is a long stretch of time between each redraw where we
get input events from the user and other events (like e.g. network I/O).
Some events, like mouse motion are compressed so that we only get a single
mouse motion event per clock&nbsp;cycle.</p>
<p>Once the <em>Events</em> phase is over we pause all external events and run the
redraw loop. First is the <em>Update</em> phase, where all animations are run to
calculate the new state based on the estimated time the next frame will be
visible (available via the frame clock). This often involves geometry
changes which drives the next phase, <em>Layout</em>. If there are any changes in
widget size requirements we calculate a new layout for the widget hierarchy
(i.e. we assign sizes and positions). Then we go to the <em>Paint</em> phase where
we redraw the regions of the window that need&nbsp;redrawing.</p>
<p>If nothing requires the <em>Update</em>/<em>Layout</em>/<em>Paint</em> phases we will stay in the
<em>Events</em> phase forever, as we don’t want to redraw if nothing changes. Each
phase can request further processing in the following phases (e.g. the
<em>Update</em> phase will cause there to be layout work, and layout changes cause&nbsp;repaints).</p>
<p>There are multiple ways to drive the clock, at the lowest level you can
request a particular phase with <a href="javascript:void(0)" data-namespace="Gdk" data-link="method.FrameClock.request_phase.html" class="external"><code>gdk_frame_clock_request_phase()</code></a>
which will schedule a clock beat as needed so that it eventually reaches the
requested phase. However, in practice most things happen at higher&nbsp;levels:</p>
<ul>
<li>If you are doing an animation, you can use
  <a href="method.Widget.add_tick_callback.html"><code>gtk_widget_add_tick_callback()</code></a> which will cause a regular beating
  of the clock with a callback in the <em>Update</em> phase until you stop the&nbsp;tick.</li>
<li>If some state changes that causes the size of your widget to change you
  call <a href="method.Widget.queue_resize.html"><code>gtk_widget_queue_resize()</code></a> which will request a <em>Layout</em>
  phase and mark your widget as needing&nbsp;relayout.</li>
<li>If some state changes so you need to redraw some area of your widget you
  use the normal <a href="method.Widget.queue_draw.html"><code>gtk_widget_queue_draw()</code></a> set of functions. These
  will request a <em>Paint</em> phase and mark the region as needing&nbsp;redraw.</li>
</ul>
<p>There are also a lot of implicit triggers of these from the <span class="caps">CSS</span> layer (which
does animations, resizes and repaints as&nbsp;needed).</p>
<p>Hierarchical&nbsp;drawing</p>
<p>During the Paint phase we will send a single expose event to the toplevel
window. The event handler will create a cairo context for the window and
emit a <a href="signal.Widget.draw.html"><code>GtkWidget::draw</code></a> signal on it, which will propagate down
the entire widget hierarchy in back-to-front order, using the clipping and
transform of the Cairo context. This lets each widget draw its content at
the right place and time, correctly handling things like partial
transparencies and overlapping&nbsp;widgets.</p>
<p>When generating the event, <span class="caps">GDK</span> also sets up double buffering to avoid the
flickering that would result from each widget drawing itself in turn. the
section called <a href="drawing-model.html#double-buffering">“Double buffering”</a> describes the double
buffering mechanism in&nbsp;detail.</p>
<p>Normally, there is only a single Cairo context which is used in the entire
repaint, rather than one per <code>GdkWindow</code>. This means you have to respect
(and not reset) existing clip and transformations set on&nbsp;it.</p>
<p>Most widgets, including those that create their own <code>GdkWindow</code>s have a
transparent background, so they draw on top of whatever widgets are below
them. This was not the case in <span class="caps">GTK</span> 2 where the theme set the background of
most widgets to the default background color. (In fact, transparent
<code>GdkWindow</code>s used to be&nbsp;impossible.)</p>
<p>The whole rendering hierarchy is captured in the call stack, rather than
having multiple separate draw emissions, so you can use effects like e.g.
<code>cairo_push/pop_group()</code> which will affect all the widgets below you in the
hierarchy. This makes it possible to have e.g. partially transparent&nbsp;containers.</p>
<h3 id="scrolling">Scrolling<a class="md-anchor" href="drawing-model.html#scrolling" title="Permanent link"></a></h3>
<p>Traditionally, <span class="caps">GTK</span> has used self-copy operations to implement scrolling with
native windows. With transparent backgrounds, this no longer works. Instead,
we just mark the entire affected area for repainting when these operations
are used. This allows (partially) transparent backgrounds, and it also more
closely models modern hardware where self-copy operations are problematic
(they break the rendering&nbsp;pipeline).</p>
<p>Since the above causes some overhead, we introduce a caching mechanism.
Containers that scroll a lot (<code>GtkViewport</code>, <code>GtkTextView</code>, <code>GtkTreeView</code>,
etc) allocate an offscreen image during scrolling and render their children
to it (which is possible since drawing is fully hierarchical). The offscreen
image is a bit larger than the visible area, so most of the time when
scrolling it just needs to draw the offscreen in a different position. This
matches contemporary graphics hardware much better, as well as allowing
efficient transparent backgrounds. In order for this to work such containers
need to detect when child widgets are redrawn so that it can update the
offscreen. This can be done with the new
<a href="javascript:void(0)" data-namespace="Gdk" data-link="method.Window.set_invalidate_handler.html" class="external"><code>gdk_window_set_invalidate_handler()</code></a>&nbsp;function.</p>
<h3 id="double-buffering">Double buffering<a class="md-anchor" href="drawing-model.html#double-buffering" title="Permanent link"></a></h3>
<p>If each of the drawing calls made by each subwidget&#8217;s draw handler were sent
directly to the windowing system, flicker could result. This is because
areas may get redrawn repeatedly: the background, then decorative frames,
then text labels, etc. To avoid flicker, <span class="caps">GTK</span> employs a double buffering
system at the <span class="caps">GDK</span> level. Widgets normally don&#8217;t know that they are drawing
to an off-screen buffer; they just issue their normal drawing commands, and
the buffer gets sent to the windowing system when all drawing operations are&nbsp;done.</p>
<p>Two basic functions in <span class="caps">GDK</span> form the core of the double-buffering mechanism:
<a href="javascript:void(0)" data-namespace="Gdk" data-link="method.Window.begin_paint_region.html" class="external"><code>gdk_window_begin_paint_region()</code></a> and
<a href="javascript:void(0)" data-namespace="Gdk" data-link="method.Window.end_paint.html" class="external"><code>gdk_window_end_paint()</code></a>. The first function tells a <code>GdkWindow</code> to
create a temporary off-screen buffer for drawing. All subsequent drawing
operations to this window get automatically redirected to that buffer. The
second function actually paints the buffer onto the on-screen window, and
frees the&nbsp;buffer.</p>
<h3 id="automatic-double-buffering">Automatic double buffering<a class="md-anchor" href="drawing-model.html#automatic-double-buffering" title="Permanent link"></a></h3>
<p>It would be inconvenient for all widgets to call
<code>gdk_window_begin_paint_region()</code> and <code>gdk_window_end_paint()</code> at the
beginning and end of their draw&nbsp;handlers.</p>
<p>To make this easier, <span class="caps">GTK</span> normally calls <code>gdk_window_begin_paint_region()</code>
before emitting the <code>GtkWidget::draw</code> signal, and then it calls
<code>gdk_window_end_paint()</code> after the signal has been emitted. This is
convenient for most widgets, as they do not need to worry about creating
their own temporary drawing buffers or about calling those&nbsp;functions.</p>
<p>However, some widgets may prefer to disable this kind of automatic double
buffering and do things on their own. To do this, call the
<a href="method.Widget.set_double_buffered.html"><code>gtk_widget_set_double_buffered()</code></a> function in your widget&#8217;s
constructor. Double buffering can only be turned off for widgets that have a
native&nbsp;window.</p>
<h4 id="disabling-automatic-double-buffering">Disabling automatic double buffering<a class="md-anchor" href="drawing-model.html#disabling-automatic-double-buffering" title="Permanent link"></a></h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">my_widget_init</span><span class="w"> </span><span class="p">(</span><span class="n">MyWidget</span><span class="w"> </span><span class="o">*</span><span class="n">widget</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="n">gtk_widget_set_double_buffered</span><span class="w"> </span><span class="p">(</span><span class="n">widget</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>

<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<p>When is it convenient to disable double buffering? Generally, this is the
case only if your widget gets drawn in such a way that the different drawing
operations do not overlap each other. For example, this may be the case for
a simple image viewer: it can just draw the image in a single operation.
This would not be the case with a word processor, since it will need to draw
and over-draw the page&#8217;s background, then the background for highlighted
text, and then the text&nbsp;itself.</p>
<p>Even if you turn off double buffering on a widget, you can still call
<code>gdk_window_begin_paint_region()</code> and <code>gdk_window_end_paint()</code> by hand to
use temporary drawing&nbsp;buffers.</p>
<h3 id="app-paintable-widgets">App-paintable widgets<a class="md-anchor" href="drawing-model.html#app-paintable-widgets" title="Permanent link"></a></h3>
<p>Generally, applications use the pre-defined widgets in <span class="caps">GTK</span> and they do not
draw extra things on top of them (the exception being <a href="class.DrawingArea.html"><code>GtkDrawingArea</code></a>).
However, applications may sometimes find it convenient to draw directly on
certain widgets like toplevel windows or event boxes. When this is the case,
<span class="caps">GTK</span> needs to be told not to overwrite your drawing afterwards, when the
window gets to drawing its default&nbsp;contents.</p>
<p><a href="class.Window.html"><code>GtkWindow</code></a> and <a href="class.EventBox.html"><code>GtkEventBox</code></a> are the two widgets that allow
turning off drawing of default contents by calling
<a href="method.Widget.set_app_paintable.html"><code>gtk_widget_set_app_paintable()</code></a>. If you call this function, they
will not draw their contents and let you do it&nbsp;instead.</p>
<p>Since the <code>GtkWidget::draw</code> signal runs user-connected handlers before the
widget&#8217;s default handler, what usually happens is&nbsp;this:</p>
<ul>
<li>Your own draw handler gets run. It paints something on the window or the
  event&nbsp;box.</li>
<li>The widget&#8217;s default draw handler gets run. If
  <code>gtk_widget_set_app_paintable()</code> has not been called to turn off widget
  drawing (this is the default), your drawing will be overwritten. An app
  paintable widget will not draw its default contents however and preserve
  your drawing&nbsp;instead.</li>
<li>The draw handler for the parent class gets run. Since both <code>GtkWindow</code> and
  <code>GtkEventBox</code> are descendants of <a href="class.Container.html"><code>GtkContainer</code></a>, their no-window
  children will be asked to draw themselves recursively, as described in the
  section called <a href="drawing-model.html#hierarchical-drawing">“Hierarchical drawing”</a>.</li>
</ul>
<p><strong>Summary of app-paintable widgets.</strong> Call <code>gtk_widget_set_app_paintable()</code>
if you intend to draw your own content directly on a <code>GtkWindow</code> and
<code>GtkEventBox</code>. You seldom need to draw on top of other widgets, and
<code>GtkDrawingArea</code> ignores this flag, as it is intended to be drawn&nbsp;on.</p>
    </div>
  </section>
</section>


    
<div id="toc" class="toc">
  <nav aria-labelledby="toc-title">
    <p id="toc-title">Content</p>
    <ul class="toc-list">
      
        
        <li class="toc-list-item"><a href="drawing-model.html#windows-and-events"><span class="link-text">Windows and events</span></a></li>
        
        <li class="toc-list-item"><a href="drawing-model.html#the-frame-clock"><span class="link-text">The frame clock</span></a></li>
        
        <li class="toc-list-item"><a href="drawing-model.html#scrolling"><span class="link-text">Scrolling</span></a></li>
        
        <li class="toc-list-item"><a href="drawing-model.html#double-buffering"><span class="link-text">Double buffering</span></a></li>
        
        <li class="toc-list-item"><a href="drawing-model.html#automatic-double-buffering"><span class="link-text">Automatic double buffering</span></a></li>
        
        <li class="toc-list-item"><a href="drawing-model.html#app-paintable-widgets"><span class="link-text">App-paintable widgets</span></a></li>
        
      
    </ul>
  </nav>
</div>


    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>
</body>
</html>